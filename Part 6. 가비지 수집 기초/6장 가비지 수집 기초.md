# 6장: 가비지 수집 기초

### 개요

흔히 GC라고 말하는 가비지 컬렉션에 대해서 알아봅니다. 가비지란 정확하게 어떤 것인지, 힙이라고 불리는 메모리 풀에 어떻게 저장되어 있는지, 가비지 컬렉션은 무엇인지 알아봅니다.

---

### GC가 준수해야할 것

- GC는 자바 환경에서 JVM이 실행하는 꽤 돋보이는 기능입니다. 하지만 최초엔 언어 수준에서 메모리를 핸들링하지 못하게 만들었다는 이유로 꽤 많은 반감이 있었다고 합니다.
    - 하지만 자바는 블루컬러를 위한 언어라고 불릴만큼 개발자의 생산성에 많은 심혈을 기울이고 있습니다. 따라서 굉장히 심오한 고민이 필요한 메모리 핸들링을 Garbage Collector에 위임했습니다. 아마 제가 직접 C에서 malloc() 같은 메서드를 통해 직접 메모리를 핸들링했다면 과연 이 책을 읽을 수 있었을지 의문이네요.
- GC의 구현체가 반드시 준수해야 하는 두 가지 원칙이 있습니다. 바로 알고리즘은 반드시 모든 가비지를 수집해야만 한다는 것과 살아있는 객체를 수집해서는 안된다는 것입니다.
    - 살아있는 객체를 수집하는 건 프로그램에게 허용되지 않은 메모리 접근을 시도할 때 발생하는 **세그먼테이션 결함**을 유발합니다. 또한 프로그램의 데이터가 오염되는 결과도 발생하죠.

---

### GC의 기초, MS(Mark and Sweep)

- 있는 그대로 해석해보면 ‘표시해서 청소하기'입니다. GC의 가비지 수집의 기초는 해석한 그대로입니다. 살아있지 않다고 판단되는 놈들을 마크해서 그 녀석이 위치한 메모리를 재사용할 수 있도록 치우는 것입니다. 이것이 GC의 기본 메커니즘입니다.
    - 이 때 GC의 대상이 되는 ‘회수되지 않은 객체'를 보관하기 위해선 할당 리스트라는 배열을 사용합니다.
    - 살아있는 객체는 DFS 방식으로 탐색하고, 이를 통해 생성된 그래프는 **라이브 객체 그래프(Live Object Graph)** 라고 부릅니다.

---

### 핫스팟 VM 런타임 개요

- 핫스팟 VM에 종속되있지만 일반적으로 사용하는 VM인만큼 구현체에 대해서 조금 알아봅시다.
- 핫스팟은 런타임 시 Ordinary Object Pointer, OOP라는 구조체로 자바 객체를 나타냅니다. 이를 구성하는 요소 중 instanceOop는 자바 클래스의 인스턴스를 표현하는 자료구조입니다.
    - 모든 객체에 대해 **인스턴스 관련 메타데이터를 가리키는 Mark 워드**와 **클래스 메타데이터를 가리키는 Klass 워드**라는 각각의 포인터를 합친 객체 헤더로 시작합니다.
        
        > *KlassOop는 JVM 클래스로더가 로드한 Class 객체를 JVM 수준에서 나타난 구조체*
        > 
    - 핫스팟에서 Java Heap 내에 위치하는 것은 반드시 객체 헤더를 가져와야 한다는 기본 원칙이 존재했습니다. Java 7까지는 **클래스와 메소드의 메타데이터 저장하기 위해 PermGen 영역을 사용**했지만 **Java 8부터는 Metaspace 영역으로 대체**되었습니다. 그리고 그 위치가 Java Heap이 아닌 C heap과 Thread Stack이 위치한 Native Memory로 변경됐습니다. 따라서 Java 8부터는 Klass 워드가 JVM 프로세스의 메모리 안이긴하지만 Java Heap 밖을 가리키기 때문에 헤더가 사라지게 됐습니다.
    - oop는 대부분 기계어 워드여서 CPU의 워드에 맞는 사이즈로 크기가 지정됩니다. 하지만 이 경우 메모리가 크게 낭비될 우려가 있어 **압축 oop**라는 기법이 제공됩니다. 이는 Java 7 버전 이상, 64비트 힙의 경우 디폴트입니다.
- 핫스팟의 oop의 전체 상속 구조는 아래와 같습니다. 아래 구조체를 사용해 하나의 포인터는 클래스 메타데이터를 가리키고 나머지 하나의 포인터는 인스턴스 메타데이터를 가리킵니다.
    - oop(추상 베이스) 상속 구조
        - instanceOop(인스턴스 객체)
        - methodOop(메서드 표현형)
        - arrayOop(배열 추상 베이스)
        - symbolOop(내부 심볼/String 클래스)
        - klassOop(Klass 헤더, Java 7 이전만)
        - markOop
- 핫스팟 내에서 메모리 풀(Java Heap 영역) 외부에서 내부를 가리키는 포인터는 **GC 루트**라고 부릅니다. 내부에서 내부를 가리키는 것은 내부 포인터라고 부릅니다. GC 루트는 이 내부 포인터와 정반대의 성격을 갖기 때문에 외부 포인터입니다.
    - GC 루트가 외부에서 내부를 가리키는 만큼 Java Heap 밖에 존재하는 요소들이 대부분 속합니다. 아래는 GC 루트의 종류입니다.
        - 스택 프레임 → Runtime Data Area에서 쓰레드가 생성될 때마다 별도로 생성되는 Java Stacks 내부의 쌓이는 자료구조를 말합니다. 메서드별로 하나씩 생성되며 내부에는 Local Variable Section, Constant Pool, Frame Data 세 가지 영역으로 나뉩니다.
        - JNI → Java Native Interface 입니다. 자바의 경우 운영체제의 고유 기능을 사용하기 위해 C, C++로 작성된 모듈들을 사용해야하는 경우가 있습니다. 그 때 이를 호출하기 위한 Java 메서드와 Native Method를 연결해주는 것이 바로 JNI입니다.
        - 레지스터
        - (JVM 코드 캐시에서)코드 루트
        - 전역 객체
        - 로드된 클래스의 메타데이터
    - 핫스팟은 자바 힙을 관리할 때 **시스템 콜을 하지 않습니다**. 꼭 기억하세요.

---

### GC는 왜 일어날까요?

- 원인은 두 가지입니다. 바로 **할당률**과 **객체 수명**이죠. 가비지 컬렉팅은 말 그대로 쓰레기를 수집하는 일입니다. 여기서 쓰레기가 의미하는 것은 더이상 사용되지 않지만 메모리를 점유하고 있는 것을 말합니다. 따라서 가비지가 얼마나 메모리를 점유하는지에 대한 할당률과 가비지가 되리라 예상되는 객체들의 수명을 예상하는 일은 중요하죠.
    - 일정 기간동안 새로 생성된 객체가 사용한 메모리량을 측정하는 할당률은 객체 수명에 비해 구하기 쉽습니다. 하지만 객체 수명은 파악하기가 어렵습니다.
    - 따라서 JVM은 ‘새로 생성된 객체는 생성된 후 아주 짧은 시간만 살아있는 객체가 대부분이다. 하지만 그 외의 객체들은 기대 수명이 훨씬 길다’ 라는 **Weak Generational Hypothesis, 약한 세대 가설**에 기반합니다. Mark And Sweep 과정은 위 가설에 입각한 메커니즘으로 동작합니다. 아래는 그 동작 과정을 간단하게 표현한 내용입니다.
        - 객체마다 ‘세대 카운트(generational count, 객체가 지금까지 무사히 통과한 가비지 컬렉션 횟수)’를 셉니다.
        - 큰 객체를 제외한 나머지 객체는 Eden(에덴 영역, 혹은 Nursery) 공간에 생성합니다. 만약 여기서 가비지 컬렉션 대상이 되지 않고 살아남으면 다른 곳(Survivor)으로 옮깁니다.
        - 충분히 오래 살아남은 객체들은 별도의 메모리 영역(Old 혹은 Tenured) 세대에 보관합니다.
    - 여기서 집중해야되는 것은 어떻게 GC root(외부)에서 영 세대 내부를 가리키는 포인터를 추적하는 기법입니다. 만약 이 기법이 없다면 우린 매번 객체 그래프를 모두 확인해서 옮겨진 메모리 위치가 어딘지 확인해야만 했을 겁니다.
        - GC에 대해 다루는 내용들을 살펴보면 Eden → Survivor → Old 영역으로 인스턴스들이 옮겨지는 동작에만 집중하는 것을 많이 봤었습니다. 그 때마다 그렇다면 다른 곳에서 그 아이들을 어떻게 추적하는 걸까?에 대한 의문이 조금 있었는데 다행이네요.
    - 핫스팟은 **카드 테이블**이라는 테이블에 늙은 객체가 젊은 객체를 참조하는 정보를 기록합니다.
        - 다만 ‘늙은 객체가 젊은 객체를 참조할 일은 거의 없다'는 것이 약한 세대별 가설의 두 번째 포인트여서 이 내용이 많이 언급되지 않은게 아닐까라고 생각되네요.

---

### Hotspot VM의 GC

- 일반적으로 우리가 사용하는 객체들은 에덴 영역에 생성됩니다. 그리고 사용 여부에 따라 이들을 타 영역으로 이동시키는데요. 이를 우린 **방출**이라고 부릅니다.
    - JVM은 에덴을 여러 버퍼로 나눠 각 애플리케이션마다 고유의 영역 **스레드 로컬 할당 버퍼(Thread-Local Allocation Buffer, TLAB)** 을 가지도록 합니다. 이를 통해 스레드는 타 스레드가 자신의 버퍼에 접근할 수도 있다는 근심걱정을 없앨 수 있습니다.
        - 만약 특정 스레드가 메모리를 많이 사용한다면 버퍼를 내주는 오버헤드를 줄이기 위해 더 큰 TLAB을 건네줍니다.
- 우리는 에덴 영역에서 생명줄이 연장된 객체들은 Survivor 영역으로 옮겨진다고 알고 있습니다. 그런데 왜 굳이 서바이버 영역으로 옮기는 걸까요? 바로 에덴 영역에 존재한 단명 객체가 바로 테뉴어드 세대로 옮겨진다면 **풀 GC 발생 빈도가 줄어들기 때문**입니다.
    - 서바이버 영역에 저장되는 객체들은 반구형이라고 불립니다. 이들은 새로 수집되는 경우는 완전히 비워진 곳에, 기존에 존재한다면 압착된 채로 다른 서바이버 영역으로 옮겨집니다. 이것은 서바이버 영역이 두 가지 기본적인 특성을 지닌다는 것을 의미합니다.
    - 이렇게 서바이버 영역으로 에덴 영역에 존재하던 객체들을 옮기는 것을 **Hemispheric Evacuating Collector, 반구형 수집기**라고 부릅니다.
        - 가비지 컬렉터가 라이브 반구(에덴 → 서바이버 영역으로 옮겨지는 객체)를 수집할 때 객체(서바이버 영역에 존재하던)들은 다른 반구(비어있는 서바이버 영역)로 압착시켜 옮기고 수집된 반구(다른 서바이버 영역)는 비워서 재사용합니다.
        - 두 개의 서바이버 영역 중 한 공간은 반드시 완전히 비어있다.
    - 위 메커니즘을 따르게 되면 서바이버 영역에는 실제로 보관 가능한 메모리의 2배를 사용합니다. 하지만 이 공간이 크지 않다면 유용합니다. 일반적으로 서바이버 공간은 에덴 영역보다 작으며 그 역할은 **영 세대 수집을 교환하는 것**입니다.

---

### Parallel Collector

- Java 8 이전까지의 JVM의 디폴트 가비지 컬렉터는 Parrel Collector 였습니다. 패러럴 컬렉터는 처리율에 최적화되어 있으며 Young GC, Full GC 모두 Full STW를 일으킵니다.
    - 디폴트 가비지 컬렉터는 `java -XX:+PrintCommandLineFlags` 명령어로 확인이 가능합니다.
- 여기서 **Parallel Collector의 한계점**이 드러납니다. 세대 전체를 대상으로 효율적으로 가비지를 수집하지만 Full STW는 생각보다 치명적인 단점입니다.
    - 영 세대의 경우 약한 가설로 인해 상당히 적은 객체만 살아남기 때문에 STW가 문제가 되지 않습니다. 하지만 올드 영역은 경우가 다릅니다.
    - 디폴트 크기가 영 세대의 7배나 되기 때문에 Full GC 시 STW 시간이 훨씬 깁니다. 또한 Old 영역에는 장수한 객체들이기 때문에 살아남는 객체를 체크하는 마킹 시간도 그 수에 비례해 늘어납니다. 즉 수집 성능에 힙 사이즈가 미치는 영향은 꽤 큽니다. 즉 **수집 성능과 힙 사이즈는 반비례한다**는 것이죠.
- 여기서 매우 헷갈린 점이 하나 있습니다. Java 8부터는 `XX:+UseParallelGC` 옵션이 디폴트로 적용되어 Parallel Collector가 디폴트로 사용되는데요. 서적 내에서는 Parallel GC를 설명할 때 Young GC에 대해서만 얘기하고 Full GC는 얘기하지 않더군요. 그래서 Young, Old 전체를 Parallel GC를 사용하는지 헷갈렸었는데 다행히 옵션 별로 각 영역에 어떤 GC를 사용하는지 표시한 링크를 찾았습니다.
    - `XX:+UseParallelGC`에서는 Young, Old 영역 모두 Parallel GC를 사용합니다. 만약 Old 영역에서 진행되는 Parallel Compaction을 사용하고 싶지 않은 경우에는 `-XX:-UseParallelOldGC` 옵션을 활성화해서 Old 영역을 Serial GC하도록 설정하면 됩니다.
    - [whats-the-difference-between-parallelgc-and-paralleloldgc by stackoverflow](https://stackoverflow.com/questions/6236726/whats-the-difference-between-parallelgc-and-paralleloldgc)
    - [HotSpot JVM garbage collection options cheat sheet](http://blog.ragozin.info/2011/07/hotspot-jvm-garbage-collection-options.html)
    - [HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html)
- Young GC는 스레드가 에덴 영역에 객체를 할당하려할 때 **자신이 할당받은** **TLAB에 빈 공간이 없고 JVM이 새 TLAB를 할당해줄 수 없을 때 발생**합니다. 이 때 JVM은 STW를 발생시킵니다. 아래는 STW동안 가비지 컬렉션의 순서입니다.
    - 핫스팟은 에덴 영역과 비어있지 않은 서바이버 공간인 영 세대를 탐색해 가비지가 아닌 객체를 고릅니다.
        - 마킹 스캔 작업의 시작점은 GC 루트와 올드 세대에서 출발하는 GC 루트를 식별하기 위한 카드 테이블입니다.
    - 살아남은 영 세대의 객체들은 가비지 컬렉터에 의해 비어있는 서바이버 공간으로 모두 방출되며 동시에 세대 카운트가 증가됩니다.
    - 기존에 존재하던 객체가 모두 방출되어 비어있는 서바이버 영역을 재사용 가능한 빈 공간으로 표시합니다.
    - STW로 인해 멈춰있던 애플리케이션 스레드를 재시작하고 TLAB를 애플리케이션 스레드에 배포하는 프로세스를 재개합니다.

---

### ParallelOld GC

- ParallelOld Collector는 자바 8에서 디폴트로 사용되는 Old 세대 수집기입니다. Parallel GC는 객체를 방출(서바이버 영역으로 옮기는)하지만 ParallelOld GC는 Tunured 공간 안에서 객체들을 압축시킵니다.
    - 만약 Old 세대에 방출할 공간이 없으면 객체들을 Compaction을 통해 재배치합니다. 이는 수명을 다한 객체가 죽고 빠져 버려진 공간을 회수하기 위한 목적입니다.

---

### 할당의 역할

- 자바의 가비지 수집 프로세스는 일반적으로 불확정적이고 불규칙적으로 발생합니다. 그 이유는 메모리 할당 요청을 수용하지 못할 때에만 발생하기 때문이죠. 이러한 불규칙적인 GC 사이클은 가비지 수집의 중요한 특징입니다.
- 일반적으로 메모리 사용 패턴이 단순 톱니형으로 표시되는 경우가 힙을 효율적으로 사용할 때 나타나는 패턴입니다.
