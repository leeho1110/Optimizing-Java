# 6장: 가비지 수집 기초

### 개요

흔히 GC라고 말하는 가비지 컬렉션에 대해서 알아봅니다. 가비지란 정확하게 어떤 것인지, 힙이라고 불리는 메모리 풀에 어떻게 저장되어 있는지, 가비지 컬렉션은 무엇인지 알아봅니다.

---

### GC가 준수해야할 것

- GC는 자바 환경에서 JVM이 실행하는 꽤 돋보이는 기능입니다. 하지만 최초엔 언어 수준에서 메모리를 핸들링하지 못하게 만들었다는 이유로 꽤 많은 반감이 있었다고 합니다.
    - 하지만 자바는 블루컬러를 위한 언어라고 불릴만큼 개발자의 생산성에 많은 심혈을 기울이고 있습니다. 따라서 굉장히 심오한 고민이 필요한 메모리 핸들링을 Garbage Collector에 위임했습니다. 아마 제가 직접 C에서 malloc() 같은 메서드를 통해 직접 메모리를 핸들링했다면 과연 이 책을 읽을 수 있었을지 의문이네요.
- GC의 구현체가 반드시 준수해야 하는 두 가지 원칙이 있습니다. 바로 알고리즘은 반드시 모든 가비지를 수집해야만 한다는 것과 살아있는 객체를 수집해서는 안된다는 것입니다.
    - 살아있는 객체를 수집하는 건 프로그램에게 허용되지 않은 메모리 접근을 시도할 때 발생하는 **세그먼테이션 결함**을 유발합니다. 또한 프로그램의 데이터가 오염되는 결과도 발생하죠.

---

### GC의 기초, MS(Mark and Sweep)

- 있는 그대로 해석해보면 ‘표시해서 청소하기'입니다. GC의 가비지 수집의 기초는 해석한 그대로입니다. 살아있지 않다고 판단되는 놈들을 마크해서 그 녀석이 위치한 메모리를 재사용할 수 있도록 치우는 것입니다. 이것이 GC의 기본 메커니즘입니다.
    - 이 때 GC의 대상이 되는 ‘회수되지 않은 객체'를 보관하기 위해선 할당 리스트라는 배열을 사용합니다.
    - 살아있는 객체는 DFS 방식으로 탐색하고, 이를 통해 생성된 그래프는 **라이브 객체 그래프(Live Object Graph)**라고 부릅니다.

---

### 핫스팟 VM 런타임 개요

- 핫스팟 VM에 종속되있지만 일반적으로 사용하는 VM인만큼 구현체에 대해서 조금 알아봅시다.
- 핫스팟은 런타임 시 Ordinary Object Pointer, OOP라는 구조체로 자바 객체를 나타냅니다. 이를 구성하는 요소 중 instanceOop는 자바 클래스의 인스턴스를 표현하는 자료구조입니다.
    - 모든 객체에 대해 **인스턴스 관련 메타데이터를 가리키는 Mark 워드**와 **클래스 메타데이터를 가리키는 Klass 워드**라는 각각의 포인터를 합친 객체 헤더로 시작합니다.
        
        > *KlassOop는 JVM 클래스로더가 로드한 Class 객체를 JVM 수준에서 나타난 구조체*
        > 
    - 핫스팟에서 Java Heap 내에 위치하는 것은 반드시 객체 헤더를 가져와야 한다는 기본 원칙이 존재했습니다. Java 7까지는 **클래스와 메소드의 메타데이터 저장하기 위해 PermGen 영역을 사용**했지만 **Java 8부터는 Metaspace 영역으로 대체**되었습니다. 그리고 그 위치가 Java Heap이 아닌 C heap과 Thread Stack이 위치한 Native Memory로 변경됐습니다. 따라서 Java 8부터는 Klass 워드가 JVM 프로세스의 메모리 안이긴하지만 Java Heap 밖을 가리키기 때문에 헤더가 사라지게 됐습니다.
    - oop는 대부분 기계어 워드여서 CPU의 워드에 맞는 사이즈로 크기가 지정됩니다. 하지만 이 경우 메모리가 크게 낭비될 우려가 있어 **압축 oop**라는 기법이 제공됩니다. 이는 Java 7 버전 이상, 64비트 힙의 경우 디폴트입니다.
- 핫스팟의 oop의 전체 상속 구조는 아래와 같습니다. 아래 구조체를 사용해 하나의 포인터는 클래스 메타데이터를 가리키고 나머지 하나의 포인터는 인스턴스 메타데이터를 가리킵니다.
    - oop(추상 베이스) 상속 구조
        - instanceOop(인스턴스 객체)
        - methodOop(메서드 표현형)
        - arrayOop(배열 추상 베이스)
        - symbolOop(내부 심볼/String 클래스)
        - klassOop(Klass 헤더, Java 7 이전만)
        - markOop
- 핫스팟 내에서 메모리 풀(Java Heap 영역) 외부에서 내부를 가리키는 포인터는 **GC 루트**라고 부릅니다. 내부에서 내부를 가리키는 것은 내부 포인터라고 부릅니다. GC 루트는 이 내부 포인터와 정반대의 성격을 갖기 때문에 외부 포인터입니다.
    - GC 루트가 외부에서 내부를 가리키는 만큼 Java Heap 밖에 존재하는 요소들이 대부분 속합니다. 아래는 GC 루트의 종류입니다.
        - 스택 프레임 → Runtime Data Area에서 쓰레드가 생성될 때마다 별도로 생성되는 Java Stacks 내부의 쌓이는 자료구조를 말합니다. 메서드별로 하나씩 생성되며 내부에는 Local Variable Section, Constant Pool, Frame Data 세 가지 영역으로 나뉩니다.
        - JNI → Java Native Interface 입니다. 자바의 경우 운영체제의 고유 기능을 사용하기 위해 C, C++로 작성된 모듈들을 사용해야하는 경우가 있습니다. 그 때 이를 호출하기 위한 Java 메서드와 Native Method를 연결해주는 것이 바로 JNI입니다.
        - 레지스터
        - (JVM 코드 캐시에서)코드 루트
        - 전역 객체
        - 로드된 클래스의 메타데이터
    - 핫스팟은 자바 힙을 관리할 때 **시스템 콜을 하지 않습니다**. 꼭 기억하세요.

---