# JVM Internals

### Thread

- intro
    - 쓰레드는 프로그램 안에서 실행되는 스레드를 의미합니다. JVM은 동시에 실행되는 다수개의 스레드를 허용하며 OS 스레드와 일대일로 매핑됩니다.
    - Thread local storage, allocation buffers, synchronization ojbects, stackts and program counter와 같은 스레드를 위한 모든 상태가 준비되면 OS 스레드가 생성됩니다. 이 후 자바 스레드가 종료되면 OS 스레드가 회수됩니다.
    - OS는 모든 스레드를 예약하고 사용가능한 CPU에 이들을 디스패치하는 책임을 갖고 있습니다. OS 스레드가 초기화되면 Java 스레드 안의 `run()` 메서드를 호출합니다. run() 메서드가 반환되면 경우 포착되지 않은 예외가 처리되며 OS 스레드는 종료되는 스레드가 마지막 스레드인지 판단해 JVM 종료 여부를 결정합니다(종료되는 스레드가 데몬 스레드가 아닌지를 의미합니다).
    - 스레드가 종료되면 OS 스레드, 자바 스레드 모두 리소스가 해제됩니다.
- JVM System Threads
    - jconsole이나 다른 디버거를 확인하면 JVM 백그라운드에서 수많은 스레드가 동작하고 있는 것을 확인할 수 있습니다. Hospot JVM 내부에는 아래와 같은 스레드들이 동작하고 있습니다.
        - VM thread: 이 스레드는 JVM이 세이프 포인트에 도달한 뒤 수행해야하는 작업(ex. STW 후 진행되는 GC, 스레드 스택 덤프, 스레드 일시 중단 및 biased locking revocation)이 나타날 떄까지 기다립니다. 이러한 작업이 VM 스레드에서 발생해야 하는 이유는 모두 JVM이 힙에 대한 수정이 발생할 수 없는 안전한 지점에 있어야 하기 때문입니다. 짧게는 메모리 오염이 발생하지 않기 위해서입니다.
        - Periodic task thread: 이 스레드는 주기적으로 실행되어야 하는 스케쥴링 작업같은 타이머 이벤트(ex. 인터럽트)에 대한 동작을 수행합니다.
        - GC thread(s): JVM 내부에서 발생하는 다양한 GC 작업을 지원합니다. 위에서 발생하는 STW 상태에서 진행되는 GC 외의 다른 GC를 의미합니다.
        - Compiler thread(s): 런타임에서 바이트 코드를 네이티브 코드로 컴파일합니다.
        - Signal dispatcher thread: JVM 프로세스로 전달된 시그널을 수신하고 적절한 JVM 메소드를 호출해 처리합니다.

---

### Per Thread

- Program Counter(PC)
    - 네이티브 메서드가 아닌 자바 메서드의 현재 명령어(또는 opcode) 주소입니다. 만약 네이티브 메서드인 경우 프로그램 카운터값은 undefiened입니다. 여기서 가리키는 메모리 주소는 Method Aread(~Java 7), Meataspace(Java 8+) 영역을 가리킵니다.
- Stack
    - 각 스레드는 각자만의 고유 스택을 갖습니다. 이 스택에는 호출되는 메서드별로 스택 프레임이 생성되어 쌓이게 됩니다. 프레임은 모든 메서드 호출에 새롭게 생성되어 push되며 정상적인 반환 혹은 메서드 호출 중 예외가 반환될 때 pop됩니다. 스택은 push,pop 외의 별도의 조작 방법은 없기 때문에 힙에 할당될 수 있고 연속적으로 배치될 필요가 없습니다.
- Native Stack
    
    <p align="center"><img src="img/native-method.png"></p>
    
    - 모든 JVM이 네이티브 메서드를 지원하진 않습니다. 하지만 이를 지원하는 경우 Java Native Invocation, JNI를 위한 C-linkage model를 사용하도록 구현되는 경우 네이티브 스택은 C stack이 됩니다. 이 경우 인자의 순서와 반환값은 일반적인 C 프로그램과 동일합니다. 네이티브 메서드는 JVM 구현에 따라 다르지만 일반적으로 JVM 내부로 콜백되고 Java 메서드를 호출합니다.
    - 앞서 자바 메서드가 호출되는 경우 스택 프레임이 생성된다고 말했습니다. 여기서 만약 네이티브 메서드를 수행하는 경우 Native Stack에 새로운 스택 프레임이 생성되어 푸시된 뒤 메서드가 수행됩니다. 수행이 완료되면 네이티브 메서드를 수행한 스택 프레임으로 돌아가지 않고 **새로운 스택 프레임을 생성**해 작업을 수행합니디ㅏ.
    - 이 때 각 스레드별 스택의 크기는 동적일수도 고정될수도 있스빈다. 만약 스레드에 허용된 스택의 크기보다 더 큰 공간이 필요한 경우 StackOverflowError 예외가 발생합니다.
    - 만약 스레드에 새로운 프레임이 필요하지만 만약 이를 할당할 메모리가 없는 경우라면 OutOfMemoryError 예외가 발생합니다.
- Frame
    - 스택에 추가되는 스택 프레임은 내부적으로 아래와 같은 값들을 갖습니다.
        - Local variable array
        - Return value
        - Operand stack
        - Reference to runtime constant pool for class of the current method(현재 메서드가 선언된 클래스에 대한 런타임 상수 풀에 대한 참조)
    1. Local variale array
        - 지역 변수 배열에는 메서드의 수행동안 사용되는 모든 메서드들이 들어갑니다. this에 대한 참조, 메서드 파라미터, 내부에서 선언된 지역변수들이 포함됩니다. 기본 타입들은 실제 값이, 참조 변수들은 객체가 저장된 힙 영역의 참조가 저장됩니다. 만약 메서드가 다른 메서드에 의해 호출된 경우 돌아갈 주소도 저장됩니다.
        - 해당 영역은 0부터 시작되는 0-Base 배열로 구성됩니다. 로컬 메서드, 인스턴스 메서드에는 자동으로 0번 인덱스에 hidden this 레퍼런스가 저장되며, 이를 통해 힙 영역에 있는 클래스의 인스턴스 데이터를 찾아갑니다. 정적 매서드의 경우 힙에 저장되지 않고 Method Area or Metaspace에 저장되기 때문에 hidden this 레퍼런스가 존재하지 않습니다.
        - 64비트의 크기를 갖는 long, double 자료형(2개의 슬롯을 차지)을 제외한 나머지는 하나의 슬롯을 차지합니다.
    2. Operand stack
        - 바이트코드 인스트럭션의 실행동안 일반적인 CPU에서 레지스터가 사용되는 방식과 비슷하게 사용됩니다.