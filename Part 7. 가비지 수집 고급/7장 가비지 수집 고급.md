# 7장: 가비지 수집 고급

### 개요

6장에서는 Hotspot VM의 개요와 런타임 동작 시 일어나는 일들을 알아봤습니다. 이번 장에서는 가비지 수집의 이론에 대해서 알아보겠습니다. Parallel Collector부터 CMS, G1 등 중단 시간이 짧은 가비지 컬렉터를 알아보고 뒤에서는 셰난도아, C4, 밸런스드, 레거시 핫스팟 컬렉터도 알아보겠습니다.

---

### 가비지 컬렉터는 어떻게 선택해야되나요?

- 자바의 가비지 수집기는 탈착형입니다. 즉 자바 구현체 중에는 가비지 수집 기능이 없는 것도 존재합니다. 즉 뺐다 꼈다 할 수 있는 것이죠. 이렇게 만든 이유는 모든 상황에 적합한 가비지 컬렉터는 없기 때문입니다. 따라서 우린 서비스 운용 환경에 맞춰 적절한 가비지 컬렉터를 선택해 사용해야 합니다.
- 우리가 가비지 컬렉터를 선택할 때 고려해야할 수 있는 기준은 아래의 총 5가지입니다. 일반적으로 짧은 중단 시간을 고려하지만 반드시 그런 것은 아닙니다. 예를 들어 고도 병렬 배치 처리 혹은 빅데이터 애플리케이션에서는 작업 중지 시간이 생각보다 크리티컬하지 않습니다. 오히려 CPU 효율 및 처리율이 우수한 GC 알고리즘이 훨씬 우선순위가 높습니다.
    - 중단 시간
        - 주로 많은 관심을 받는 요소입니다. 하지만 경우에 따라 효과적이지 않은 성능 특성이 아닐수도 있다는 것을 인지해야 합니다.
    - 처리율
        - 애플리케이션 런타임에서 GC가 일어나는 시간이 몇 %인가
    - 중단 빈도
        - 가비지 컬렉터로 인해 애플리케이션이 정지하는 횟수가 얼마나 되는가
    - 회수 효율
        - GC 사이클 당 수집되는 가비지가 얼마나 되는가?
    - 중단 일관성
        - 중단 시간이 일정한 편인가?

---

### Concurrent GC 이론

- 일반적으로 가비지 컬렉터는 말 그대로 가비지만 수집하는 것에 온 신경을 쏟습니다. 컬렉터가 어떤 도메인 환경에 처해있는지는 전혀 고려되지 않았기 때문에 도메인에 특화된 가비지 컬렉팅, 즉 **효과적인 중단 시점을 결정하는 것은 매우 어렵습니다**. 또한 메모리 할당은 불확정성을 유발하는 직접적인 원인이기에 최신 가비지 컬렉터의 성능 개선의 관점은 주로 **불확정적인 STW 중단 문제의 해결**입니다.
    - 쉽게 얘기해서 GC를 수행하며 STW가 언제 발생하는지를 예측하고 싶다는 것입니다. 뒤에서 나오겠지만 우리가 알고 있는 STW에서의 쓰레드 정지는 “하나, 둘, 셋!” 하고 멈추지 않습니다. **먼저 멈추는 스레드와 나중에 멈추는 스레드가 존재하며 모두 정지하고 나면 특정 동작(STW GC)을 시작**합니다. 따라서 만약 언제 멈춰야하는지를 예상할 수 있다면 훨씬 도움이 되겠죠.
- 그래서 동시 GC는 이런 GC에 필요한 작업들을 애플리케이션 스레드가 동작하는 시간동안 같이 작업해 중단 시간의 최소화를 이루는 것이 목적입니다. 하지만 CMS가 말도 많고 탈도 많다는 데에는 다 이유가 있겠죠. 이런 복잡한 프로그래밍에서 동시성을 핸들링하는 것은 쉬운 일이 아니니까요.

---

### 가비지 컬렉터의 특성을 이해하기 위해 필요한 것

- 위에서 우린 가비지 컬렉팅을 수행하기 위해 스레드를 일시정지 시킨다고 했습니다. 그렇다면 JVM은 어떻게 스레드를 멈추게 하는 걸까요? “멈춰!” 하면 멈추는 것일까요? 그 비밀은 바로 **세이프 포인트(Safe Point)** 입니다.
    
    > *JVM은 사실 완전히 선제적인(fully preemptive, JVM이 끼어들어 우선순위가 낮은 스레드를 끌어내리고 우선순위가 높은 스레드로 대체하는 것이 가능한) 멀티스레드 환경이 아니다.*
    > 
    - 본문에 언급된 비밀이 하나가 있습니다. 바로 JVM은 스레드를 완벽하게 핸들링할 수 없다는 것이죠. 밤면 OS는 위에서 말한 선제 개입이 가능합니다. 따라서 JVM도 가비지 컬렉팅을 위해 OS처럼 스레드를 조정해야할 필요가 있습니다. 이를 위해 도입한 것이 바로 위에서 언급한 세이프 포인트입니다.
    - 그렇다면 왜 멈춰야 할까요? 일반적인 상황의 예시는 STW GC 상황을 예로 들 수 있습니다. 가비지 객체를 확인하려면 안정된 객체 그래프가 필요합니다. 만약 애플리케이션 스레드(변경자 스레드)의 객체 생성 및 참조 과정과 가비지 마킹 작업이 동시에 일어난다면 가비지 마킹의 결과가 계속 변경될 겁니다. 따라서 **안정된 객체 그래프를 위해선 반드시 애플리케이션 스레드를 중단**시켜야 합니다.
- 하지만 앞서 말했듯 JVM은 선제 개입이 불가능하기 때문에 스레드와 협의점을 찾아야 합니다. 따라서 JVM은 세이프 포인트를 통해 애플리케이션 스레드를 정지시키고자 할 때 아래와 같은 두 가지 규칙을 지킵니다.
    - JVM은 강제로 스레드를 세이프포인트 상태로 바꿀 수 없습니다.
        - 이는 스레드가 세이프포인트 상태로 **변경될 때까지 가만히 대기**해야 한다는 것을 의미합니다.
    - JVM은 스레드가 세이프포인트 상태에서 벗어나지 못하게 할 수 있다.
        - 다행히도 STW GC가 진행되는 동안 붙잡아 둘 수 있습니다. 만약 제멋대로 세이프포인트 상태에서 벗어나게 된다면 가비지 컬렉팅이 완료되지 않았는데도 마음대로 객체 그래프를 휘젓고 다닐테니까요.
    - 한 가지 주의해야할 점은 애플리케이션 스레드가 세이프포인트 요청을 받고 세이프포인트 상태로 바뀌기 위해 제어권을 반납하는 코드(배리어)는 반드시 VM 인터프리터 구현체, JIT 컴파일한 메서드에 생성된 기계어 어딘가에 존재해야 합니다.
- 애플리케이션 스레드는 언제 세이프포인트 상태로 바뀔까요?
    1. JVM이 전역 ‘세이프포인트 시간(time to safepoint)’ 플래그를 세팅합니다.
    2. 각 애플리케이션 스레드가 폴링을 통해 JVM이 위 플래그의 세팅했는지 확인합니다.
    3. 플래그를 확인했다면 일단 멈추고 JVM이 세이프포인트 상태에서 벗어나게 해줄 때까지 대기합니다.
    - 여기서 세이프포인트 시간 플래그를 세팅함으로써 애플리케이션 스레드는 반드시 멈추게 됩니다. 다만 위에서 언급된 것처럼 일찍 플래그를 확인한 스레드가 먼저 멈춘다고 해도 가장 마지막 스레드가 멈출 때까지 대기해야 합니다. 당연히 STW 가비지 컬렉팅의 시작도 지연되겠죠.
    - 아래는 애플리케이션 스레드가 세이프포인트 상태가 되는 구체적인 예시입니다.
        - 모니터에서 차단되는 경우
        - JNI 코드를 실행하는 경우

---
---