# 9장: JVM의 코드 실행

### 개요

이번 장에서는 JVM이 어떻게 코드를 실행시키는지 알아보겠습니다.

---

### 바이트코드를 해석하는 법

- JVM은 일반적인 하드웨어 CPU와 다르게 계산의 결과값을 보관하는 레지스터가 없습니다. 따라서 메서드별로 생성되는 스택 프레임 내부에 저장합니다.
    - x와 1+3을 비교하는 로직을 가정하겠습니다.
        - 인터프리터는 x, 1, 3을 순서대로 넣습니다.
        - 상단의 1과 3을 더한 뒤 결과값을 다시 스택에 넣습니다.
        - 최상단 4와 x를 비교합니다.

---

### 바이트코드 개요

- 스택에 들어가는 옵코드(operation code)는 1바이트로 표현됩니다. 이것이 바이트코드라고 불리는 이유입니다.
    - 총 256개 지정이 가능하며 자주 사용하는 `load` 같은 옵코드 종류는 단축형을 통해 인수 바이트 공간을 절약할 수 있습니다.
- 데이터를 가져오고(load) 저장(store)하는 카테고리의 옵코드를 확인해봅시다. 여기서 사용되는 옵코드는 1바이트, 옵코드의 인수는 상수 풀 인덱스로 2바이트를 차지합니다. 괄호 안의 인수는 앞서 말한 단축형을 지닌 옵코드가 있다는 것을 의미합니다. 어려우니 신경쓰지 않으셔도 됩니다.
    
    
    | 패밀리 명 | 인수 | 설명 |
    | --- | --- | --- |
    | load | (i1) | 지역 변수 i1 값을 스택에 로드합니다. 더하기 혹은 특정 연산을 위해 값을 가져오기 위한 옵코드입니다. |
    | store | (i1) | 스택 상단 값을 지역 변수 i1에 저장합니다. 연산 결과값을 다시 지역 변수에 저장하기 위한 옵코드입니다. |
    | ldc | c1 | 클래스 상수 풀(Class Constant Pool)의 c1번째 CP_info를 스택에 로드합니다. ex. ldc #10 → Constant Pool 내부의 10번째 CP_info를 로드하라는 의미입니다.|
    | const |  | 단순 상숫값을 스택에 로드합니다. 위의 ldc에서 로드하는 상수 풀의 상수와 단순 상수값은 다릅니다. |
    | pop |  | 스택 상단에서 값을 제거합니다. |
    | dup |  | 스택 상단에서 값을 복제합니다. |
    | getField | c1 | 스택 상단에 위치한 객체에서 Constant Pool 내부 c1이 가리키는 필드명을 찾고 그 값을 스택에 로드합니다. |
    | putField | c1 | 스택 상단 값을 Constant Pool 내부 c1이 가리키는 필드에 저장합니다. |

---

### AOT & JIT Compile

- 그냥 ‘컴파일'이라고 불리는 AOT 컴파일과 JIT 컴파일에 대해서 알아봅니다.
    - AOT는 Ahead Of Time의 약자로 컴파일러에 소스 코드를 넣고 즉시 기계어로 변환하는 기법입니다.
        - 주로 프로그램 실행 플랫폼과 프로세서 아키텍쳐에 적합한 실행 코드를 얻기 위해서 수행됩니다.
        - 하지만 대부분의 소스 코드들은 여러 플랫폼에서 수행되는 상황이 많습니다. 이를 플랫폼 독립성이 없다고 얘기합니다.
    - JIT는 Just In Time의 약자로 런타임에 중간어(Intermediate language)로 변환된 소스코드를 기계어로 변환하는 기법입니다.
        - 런타임에 기계어로 변환하는 목적은 런타임에서 수집된 실행 정보를 기반으로 최적화할 영역을 찾기 위해서입니다. 이러한 최적화 영역을 **Hotspot**이라고 합니다.
        - 핫스팟을 파악하기 위해 실행중인 메서드를 추적하는 시스템을 **프로파일링 서브시스템**이라고 합니다.
        - 최적화가 필요하다고 느껴지는 메서드를 발견하면 **에미터 서브시스템**이 컴파일 스레드를 가동해 바이트코드를 기계어로 변환합니다.
        - 하지만 런타임에 기계어로 컴파일하기 때문에 CPU 자원 소모가 동반됩니다.

---

### Hotspot JIT Basic

- 핫스팟은 기본적으로 **전체 메서드**를 컴파일 단위로 삼습니다. 메서드 하나에 해당되는 바이트 코드가 기계어로 컴파일 되며 이 작업은 컴파일러 스레드가 수행합니다. 컴파일 대상 메서드를 찾는 프로파일링 스레드도 존재합니다.
    - JVM 내부에는 일반적인 애플리케이션 스레드와 같은 스레드이지만, 별도의 목적을 갖는 스레드들이 존재합니다.
        - VM Thread
        - Periodic task thread
        - GC threads
        - Compiler threads
        - Signal dispatcher thread
- Hotspot JVM 내부에는 C1, C2라는 두 개의 JIT 컴파일러가 존재합니다. 각각 클라이언트 컴파일러, 서버 컴파일러로 불립니다. Java 10부터는 C2의 대안으로 Graal JIT 컴파일러가 등장했습니다.
    - 인터프리티드 단계에서 수집한 프로파일링 정보를 토대로 최적화 로직을 적용합니다. 본문에서는 최적화 로직 이전에 내부 표현형(representation)을 생성한다고 적혀있는데요. 정확하게 어떤 것을 의미하는지 검색을 열심히 해봐도 찾기 힘들었습니다. 중요한 것은 두 컴파일러가 생성한 내부 표현형이 다르다는 것입니다.
- Java 6부터는 인터프리터 모드에서 바이트코드를 컴파일할 때 **단계별 컴파일 모드**를 지원하며, Java 8부터는 디폴트로 활성화되어 있습니다. 인터프리터로만 코드를 컴파일하다가 이를 C1를 사용하도록, C2를 사용하도록 진화시킨다고 이해하시면 됩니다.
    - 이렇게 컴파일된 코드는 Off-heap의 **코드 캐시**라는 영역에 저장됩니다. 해당 영역은 크기가 고정되어 확장이 불가능하기 때문에 영역이 꽉차면 더이상의 JIT 컴파일이 불가능합니다. 따라서 네이티브 코드가 제거될 때마다 스위퍼 프로세스가 사용가능한 블록을 프리 리스트에 추가시켜 줍니다.
    - Java 9부터는 네이티브 코드 유형마다 별도로 저장할 수 있도록 코드 캐시 영역이 세 개의 영역으로 나눠집니다. 코드 지역성을 개선하고 메모리 단편화 현상을 줄이는 데에 도움을 줍니다.
        - JVM 내부 코드를 저장하는 non-method segment(디폴트 5MB)
        - 짧은 수명을 갖는 C1 컴파일드 코드를 저장하는 profiled-code segment(디폴트 약 122BM)
        - 긴 수명을 갖는 C2 컴파일드 코드를 저장하는 non-profiled segment(디폴트 약 122MB)
    - 네이티브 코드는 역최적화(예상한 최적화 결과가 틀렸을 때), 위에서 말한 컴파일 실행 레벨이 바뀌었을 때, 클래스가 언로딩될 때 제거됩니다.

---

### 참고자료

- [https://blogs.oracle.com/javamagazine/post/java-class-file-constant-pool](https://blogs.oracle.com/javamagazine/post/java-class-file-constant-pool)
- [https://blog.jamesdbloom.com/JVMInternals.html#constant_pool](https://blog.jamesdbloom.com/JVMInternals.html#constant_pool)
- [https://www.baeldung.com/jvm-tiered-compilation](https://www.baeldung.com/jvm-tiered-compilation)
